# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AddStockToWatchlistInput {
  ticker: String!
  watchlistId: String!
}

type AdminUser {
  avatar: String
  balance: Float!
  createdAt: DateTime!
  email: String!
  id: ID!
  isBanned: Boolean!
  name: String
  role: String!
}

type AlertRule {
  createdAt: DateTime!
  id: ID!
  ruleType: AlertRuleType!
  targetValue: Float!
  ticker: String!
}

"""The type of alert rule"""
enum AlertRuleType {
  PERCENT_CHANGE
  PRICE_ABOVE
  PRICE_BELOW
  VOLUME_SPIKE
}

type AuthPayload {
  accessToken: String!
  role: String!
  user: User!
}

input BuyStockInput {
  price: Float!
  shares: Float!
  ticker: String!
}

type BuyStockPayload {
  portfolio: Portfolio!
  transaction: Transaction!
}

type Candle {
  close: Float!
  high: Float!
  low: Float!
  open: Float!
  timestamp: Float!
  volume: Float!
}

input CreateAlertRuleInput {
  ruleType: AlertRuleType!
  targetValue: Float!
  ticker: String!
}

input CreateStockInput {
  companyName: String!
  country: String
  currency: String
  exchange: String!
  industry: String
  ipoDate: String
  isTradable: Boolean
  sector: String
  status: String
  suspendReason: String
  ticker: String!
}

input CreateWatchlistInput {
  name: String!
}

type DashboardResult {
  cashBalance: Float!
  stockPositions: [StockPosition!]!
  stocksOnlyValue: Float!
  totalPnL: Float!
  totalPortfolioValue: Float!
  totalRealizedPnL: Float!
  totalUnrealizedPnL: Float!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Dividend {
  amount: Float!
  exDate: DateTime!
  frequency: DividendFrequency!
  payDate: DateTime!
  ticker: String!
}

enum DividendFrequency {
  ANNUAL
  QUARTERLY
}

type EquityDrawdownPoint {
  date: String!
  equity: Float!
  maxDrawdown: Float!
}

type EquityPoint {
  timestamp: Float!
  value: Float!
}

type ForecastModel {
  confidenceScore: Float!
  id: String!
  modelType: String!
  prediction: Float!
  ticker: String!
  trainedAt: DateTime!
}

type Hello {
  message: String!
}

type HoldingSlice {
  percentage: Float!
  symbol: String!
  value: Float!
}

type IndicatorPoint {
  timestamp: Float!
  value: Float!
}

type IndicatorSeries {
  name: String!
  values: [IndicatorPoint!]!
}

enum Interval {
  _1d
  _1h
  _1m
  _5m
}

input LoginInput {
  email: String!
  password: String!
}

type MarketData {
  afterHours: Float
  close: Float!
  high: Float!
  id: ID!
  interval: Interval!
  low: Float!
  open: Float!
  ticker: String!
  timestamp: String!
  volume: String!
}

type MetricWithDateRange {
  endDate: Float!
  startDate: Float!
}

type MostTradedStock {
  companyName: String!
  shareOfVolume: Float!
  ticker: String!
  volume: Float!
}

type Mutation {
  addStockToWatchlist(input: AddStockToWatchlistInput!): Boolean!
  adminCreateStock(input: CreateStockInput!): Stock!
  adminForceCancelOrder(orderId: String!): Order!
  adminUpdateStock(input: UpdateStockInput!): Stock!
  banUser(userId: String!): AdminUser!
  broadcastMarketData(price: Float!, ticker: String!): MarketData!
  buyStock(input: BuyStockInput!): BuyStockPayload!
  cancelOrder(orderId: String!): Order!
  changePassword(currentPassword: String!, newPassword: String!): Boolean!
  createAlertRule(input: CreateAlertRuleInput!): AlertRule!
  createWatchlist(input: CreateWatchlistInput!): Watchlist!
  deduct(amount: Float!): Boolean!
  deleteAlertRule(id: ID!): Boolean!
  demoteFromAdmin(userId: String!): AdminUser!
  deposit(amount: Float!): Boolean!
  login(input: LoginInput!): AuthPayload!
  placeOrder(input: PlaceOrderInput!): Order!
  placeStopOrder(input: PlaceStopOrderInput!): Order!
  promoteToAdmin(userId: String!): AdminUser!
  removeStockFromWatchlist(input: AddStockToWatchlistInput!): Boolean!
  sellStock(input: SellStockInput!): SellStockPayload!
  signUp(input: SignUpInput!): AuthPayload!
  startDashboardSeeding(endDate: String!, startDate: String!): String!
  startSimulation: String!
  stopDashboardSeeding: String!
  stopSimulation: String!
  triggerOrderNotification(type: String!, userId: String!): Boolean!
  triggerPriceAlert(ticker: String!, userId: String!): Boolean!
  unbanUser(userId: String!): AdminUser!
  updateAvatar(avatarUrl: String!): User!
  updateMarketData(price: Float!, ticker: String!): MarketData!
  updateRiskConfig(input: UpdateRiskConfigInput!): RiskConfig!
}

type News {
  headline: String!
  id: String!
  publishedAt: DateTime!
  sentimentScore: Float
  source: String
  summary: String
  ticker: String!
  type: String
  url: String
}

type Order {
  createdAt: DateTime!
  id: ID!
  matchedAt: DateTime
  price: Float!
  quantity: Float!
  side: OrderSide!
  status: OrderStatus!
  ticker: String!
  timeInForce: TimeInForce!
  type: OrderType!
}

type OrderBook {
  buyOrders: [Order!]!
  sellOrders: [Order!]!
}

input OrderPaginationInput {
  endDate: String
  limit: Int! = 20
  page: Int! = 1
  side: String
  startDate: String
  status: String
  ticker: String
  userId: String
}

type OrderPaginationMeta {
  currentPage: Int!
  limit: Int!
  totalCount: Int!
  totalPages: Int!
}

type OrderPaginationResponse {
  meta: OrderPaginationMeta!
  orders: [OrderWithUser!]!
}

enum OrderSide {
  BUY
  SELL
}

enum OrderStatus {
  CANCELLED
  FILLED
  OPEN
  PARTIAL
}

"""The type of order"""
enum OrderType {
  LIMIT
  MARKET
  STOP_LIMIT
  STOP_MARKET
}

type OrderUserInfo {
  email: String!
  id: ID!
  name: String
  role: String!
}

type OrderWithUser {
  createdAt: DateTime!
  id: ID!
  matchedAt: DateTime
  price: Float!
  quantity: Float!
  side: OrderSide!
  status: OrderStatus!
  ticker: String!
  timeInForce: TimeInForce!
  triggerPrice: Float
  type: OrderType!
  user: OrderUserInfo!
}

input PlaceOrderInput {
  price: Float!
  quantity: Float!
  side: OrderSide!
  ticker: String!
  timeInForce: TimeInForce! = GTC
  type: OrderType! = LIMIT
}

input PlaceStopOrderInput {
  price: Float!
  quantity: Float!
  side: OrderSide!
  ticker: String!
  timeInForce: TimeInForce! = GTC
  triggerPrice: Float!
  type: OrderType!
}

type PnLPoint {
  date: String!
  pnl: Float!
}

type Portfolio {
  averagePrice: Float!
  quantity: Float!
  ticker: String!
}

type PortfolioChart {
  equityCurve: [EquityPoint!]!
  holdings: [HoldingSlice!]!
  totalValue: Float!
}

type PositionValidation {
  isValid: Boolean!
  maxQuantity: Float
  message: String
}

type Query {
  adminOrders(input: OrderPaginationInput!): OrderPaginationResponse!
  adminStocks(input: StockPaginationInput!): StockPaginationResponse!
  adminTransactions(input: TransactionPaginationInput!): TransactionPaginationResponse!
  adminUserOrders(input: UserOrderPaginationInput!): OrderPaginationResponse!
  adminUserTransactions(input: UserTransactionPaginationInput!): TransactionPaginationResponse!
  calculateRecommendedStopLoss(entryPrice: Float!, side: String!, ticker: String!): Float!
  candles(interval: String!, limit: Int, symbol: String!): [Candle!]!
  getAllUsers: [AdminUser!]!
  getBalance(userId: String!): Float!
  getBollingerBands(interval: Interval! = _1d, period: Float! = 20, stdDev: Float! = 2, ticker: String!): [Float!]!
  getDashboard: DashboardResult!
  getDashboardSeedingStatus: String!
  getEMA(interval: Interval! = _1d, period: Float! = 20, ticker: String!): [Float!]!
  getMyAlertRules: [AlertRule!]!
  getMyBalance: Float!
  getPortfolioSummary: String!
  getPositionPnL(ticker: String!): String!
  getRSI(interval: Interval! = _1d, period: Float! = 14, ticker: String!): [Float!]!
  getRiskConfig: RiskConfig!
  getRiskReport: RiskReport!
  getSMA(interval: Interval! = _1d, period: Float! = 20, ticker: String!): [Float!]!
  getStockPosition(ticker: String!): StockPosition
  getSystemDashboard(input: SystemDashboardInput!): SystemDashboardResult!
  getTotalPnL: String!
  getUserById(userId: String!): AdminUser!
  indicators(indicators: [String!], interval: String!, period: Float, symbol: String!): [IndicatorSeries!]!
  me: User!
  myOrders: [Order!]!
  myPortfolio: [Portfolio!]!
  myTransactions: [Transaction!]!
  myWatchlists: [Watchlist!]!
  orderBook(ticker: String!): OrderBook!
  portfolio: PortfolioChart!
  sayHello: Hello!
  simulationStatus: String!
  stock(ticker: String!): Stock
  stocks: [Stock!]!
  trades(limit: Int, symbol: String!): [TradeTick!]!
  transactionStats: TransactionStats!
  validatePortfolioRisk: RiskValidation!
  validatePositionSize(price: Float!, quantity: Float!, ticker: String!): PositionValidation!
  validateRiskPerTrade(price: Float!, quantity: Float!, stopLossPrice: Float, ticker: String!): RiskValidation!
}

type RiskConfig {
  maxLeverage: Float!
  maxPortfolioRisk: Float!
  maxPositionSizePercent: Float!
  maxRiskPerTrade: Float!
  stopLossPercent: Float!
}

type RiskReport {
  maxPositionSize: Float!
  portfolioRisk: Float!
  portfolioValue: Float!
  riskConfig: RiskConfig!
}

type RiskValidation {
  currentRisk: Float
  isValid: Boolean!
  message: String
}

input SellStockInput {
  price: Float!
  shares: Float!
  ticker: String!
}

type SellStockPayload {
  portfolio: Portfolio!
  transaction: Transaction!
}

input SignUpInput {
  email: String!
  name: String!
  password: String!
}

type Stock {
  avatar: String
  companyName: String!
  country: String
  currency: String
  dividends(limit: Float! = 12): [Dividend!]!
  exchange: String!
  forecastModels: [ForecastModel!]!
  industry: String
  insiderHolding: Float
  institutionalHolding: Float
  ipoDate: String
  isTradable: Boolean!
  marketCap: String
  marketData(interval: Interval! = _1d): [MarketData!]!
  news(limit: Float! = 20): [News!]!
  outstandingShares: String
  sector: String
  status: String
  suspendReason: String
  ticker: String!
}

input StockPaginationInput {
  companyName: String
  exchange: String
  isTradable: Boolean
  limit: Int! = 20
  page: Int! = 1
  status: String
  ticker: String
}

type StockPaginationMeta {
  currentPage: Int!
  limit: Int!
  totalCount: Int!
  totalPages: Int!
}

type StockPaginationResponse {
  meta: StockPaginationMeta!
  stocks: [Stock!]!
}

type StockPosition {
  avatar: String
  averageBuyPrice: Float!
  companyName: String!
  currentPrice: Float!
  marketValue: Float!
  quantity: Float!
  ticker: String!
  unrealizedPnL: Float!
  unrealizedPnLPercent: Float!
}

input SystemDashboardInput {
  compareEndDate: String
  compareStartDate: String
  endDate: String!
  startDate: String!
}

type SystemDashboardResult {
  arpu: MetricWithDateRange!
  averageTradeSize: MetricWithDateRange!
  churnRate: MetricWithDateRange!
  equityAndDrawdown: [EquityDrawdownPoint!]!
  marginCallAlerts: MetricWithDateRange!
  maxDrawdown: MetricWithDateRange!
  mostTradedStocks: [MostTradedStock!]!
  pnlOverTime: [PnLPoint!]!
  serviceUptime: MetricWithDateRange!
  topUsers: [TopUser!]!
  totalRevenue: MetricWithDateRange!
  totalTradesExecuted: MetricWithDateRange!
  winRate: MetricWithDateRange!
}

enum TimeInForce {
  FOK
  GTC
  IOC
}

type TopUser {
  avatar: String
  id: String!
  name: String!
  pnl: Float!
  totalValue: Float!
}

type TradeTick {
  price: Float!
  quantity: Float!
  side: String!
  timestamp: Float!
  tradeId: Float!
}

type Transaction {
  action: TransactionAction!
  id: ID!
  price: Float!
  shares: Float!
  ticker: String!
  timestamp: DateTime!
}

enum TransactionAction {
  BUY
  SELL
}

input TransactionPaginationInput {
  action: String
  endDate: String
  limit: Int! = 20
  page: Int! = 1
  startDate: String
  ticker: String
  userId: String
}

type TransactionPaginationMeta {
  currentPage: Int!
  limit: Int!
  totalAmount: Float!
  totalBuyAmount: Float!
  totalBuyCount: Int!
  totalCount: Int!
  totalPages: Int!
  totalSellAmount: Float!
  totalSellCount: Int!
}

type TransactionPaginationResponse {
  meta: TransactionPaginationMeta!
  transactions: [TransactionWithUser!]!
}

type TransactionStats {
  averagePrice: Float!
  totalBuyVolume: Float!
  totalSellVolume: Float!
  totalTransactions: Int!
  totalVolume: Float!
  uniqueStocks: Int!
  uniqueUsers: Int!
}

type TransactionWithUser {
  action: TransactionAction!
  id: ID!
  price: Float!
  shares: Float!
  ticker: String!
  timestamp: DateTime!
  totalAmount: Float!
  user: UserInfo!
}

input UpdateRiskConfigInput {
  maxLeverage: Float
  maxPortfolioRisk: Float
  maxPositionSizePercent: Float
  maxRiskPerTrade: Float
  stopLossPercent: Float
}

input UpdateStockInput {
  companyName: String
  country: String
  currency: String
  exchange: String
  industry: String
  ipoDate: String
  isTradable: Boolean
  sector: String
  status: String
  suspendReason: String
  ticker: String!
}

type User {
  avatar: String
  createdAt: DateTime!
  email: String!
  id: ID!
  isBanned: Boolean!
  name: String
  passwordHash: String!
  role: String!
}

type UserInfo {
  email: String!
  id: ID!
  name: String
  role: String!
}

input UserOrderPaginationInput {
  endDate: String
  limit: Int! = 20
  page: Int! = 1
  side: String
  startDate: String
  status: String
  ticker: String
  userId: String!
}

input UserTransactionPaginationInput {
  action: String
  endDate: String
  limit: Int! = 20
  page: Int! = 1
  startDate: String
  ticker: String
  userId: String!
}

type Watchlist {
  createdAt: DateTime!
  id: ID!
  name: String!
  stocks: [Stock!]!
}